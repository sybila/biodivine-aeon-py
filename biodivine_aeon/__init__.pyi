from typing import TypeAlias, Literal, Callable, Sequence, TypedDict, Iterator, overload, Mapping, TypeVar, Generic

LOG_NOTHING: Literal[0]
LOG_ESSENTIAL: Literal[1]
LOG_VERBOSE: Literal[2]
LOG_LEVEL: Literal[0, 1, 2]

class BddVariable:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `BddVariable` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class BddPointer:

    def __init__(self, value: bool | int | None = None) -> None:
        """
        Construct a new `BddPointer` using either a `bool` value, or an exact `int` index.

        If no value is given, defaults to `BddPointer.zero`.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...
    @staticmethod
    def zero() -> BddPointer:
        ...
    @staticmethod
    def one() -> BddPointer:
        ...
    def is_zero(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_terminal(self) -> bool:
        ...
    def as_bool(self) -> bool | None:
        ...

class BddVariableSetBuilder:
    def __init__(self, variables: Sequence[str] | None = None) -> None:
        """
        Create a new `BddVariableSetBuilder`, optionally initialized with the given list of variables.
        """
    def __eq__(self, other) -> bool:
            ...
    def __ne__(self, other) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getstate__(self) -> list[str]:
        ...
    def __setstate__(self, state: list[str]):
        ...
    def add(self, name: str) -> BddVariable:
        ...
    def add_all(self, names: Sequence[str]) -> list[BddVariable]:
        ...
    def build(self) -> BddVariableSet:
        ...


class BddVariableSet:
    def __init__(self, variables: int | Sequence[str]) -> None:
        """
        A `BddVariableSet` is typically created using a list of variable names. However, you can also create
        an "anonymous" `BddVariableSet` using a variable count `n`. In such a case, the variables are automatically
        named $(x_0, \\ldots, x_{n-1})$.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str]]:
        ...
    def variable_count(self) -> int:
        ...
    def variable_ids(self) -> list[BddVariable]:
        ...
    def variable_names(self) -> list[str]:
        ...
    def find_variable(self, variable: BddVariableType) -> BddVariable | None:
        ...
    def get_variable_name(self, variable: BddVariableType) -> str:
        ...
    def mk_false(self) -> Bdd:
        ...
    def mk_true(self) -> Bdd:
        ...
    def mk_const(self, value: BoolType) -> Bdd:
        ...
    def mk_literal(self, variable: BddVariableType, value: BoolType) -> Bdd:
        ...
    def mk_conjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_disjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_cnf(self, clauses: Sequence[BoolClauseType]) -> Bdd:
        ...
    def mk_dnf(self, clauses: Sequence[BoolClauseType]) -> Bdd:
        ...
    def mk_sat_exactly_k(self, k: int, variables: Sequence[BddVariableType] | None = None) -> Bdd:
        ...
    def mk_sat_up_to_k(self, k: int, variables: Sequence[BddVariableType] | None = None) -> Bdd:
        ...
    def eval_expression(self, expression: BoolExpressionType) -> Bdd:
        ...
    def transfer_from(self, value: Bdd, original_ctx: BddVariableSet) -> Bdd:
        ...


class Bdd:
    @overload
    def __init__(self, valuation: BddValuation | BddPartialValuation) -> None: ...
    @overload
    def __init__(self, ctx: BddVariableSet, data: bytes | str) -> None: ...
    def __init__(self, ctx, data) -> None:
        """
        A `Bdd` can be created as:

         - A conjunction of literals defined by a `BddValuation` or a `BddPartialValuation`.
         - Deserialization of an object created with `Bdd.data_string()` or `Bdd.data_bytes()`.

        When deserializing, a `BddVariableSet` has to be provided to interpret individual BDD variables.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, bytes]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __call__(self, valuation: BddValuation | list[BoolType]) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def data_string(self) -> str:
        ...
    def data_bytes(self) -> bytes:
        ...
    def to_dot(self, zero_pruned: bool = True) -> str:
        ...
    def to_expression(self) -> BooleanExpression:
        ...
    def to_dnf(self) -> list[BddPartialValuation]:
        ...
    def to_cnf(self) -> list[BddPartialValuation]:
        ...
    def node_count(self) -> int:
        ...
    def node_count_per_variable(self) -> dict[BddVariable, int]:
        ...
    def structural_eq(self, other: Bdd) -> bool:
        ...
    def semantic_eq(self, other: Bdd) -> bool:
        ...
    def implies(self, other: Bdd) -> bool:
        ...
    def root(self) -> BddPointer:
        ...
    def node_links(self, pointer: BddPointer) -> tuple[BddPointer, BddPointer]:
        ...
    def node_variable(self, pointer: BddPointer) -> None | BddVariable:
        ...
    def variable_count(self) -> int:
        ...
    def support_set(self) -> set[BddVariable]:
        ...
    def is_false(self) -> bool:
        ...
    def is_true(self) -> bool:
        ...
    def is_clause(self) -> bool:
        ...
    def is_valuation(self) -> bool:
        ...
    def cardinality(self, exact: bool = True) -> int:
        ...
    def l_not(self) -> Bdd:
        ...
    def l_and(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    def l_or(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    def l_imp(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    def l_iff(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    def l_xor(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    def l_and_not(self, other: Bdd, limit: int | None = None) -> Bdd:
        ...
    @staticmethod
    def if_then_else(
            condition: Bdd,
            then: Bdd,
            other: Bdd,
    ) -> Bdd:
        ...
    @staticmethod
    def apply2(
        left: Bdd,
        right: Bdd,
        function: Callable[[None | bool, None | bool], None | bool],
        flip_left: None | BddVariable | str = None,
        flip_right: None | BddVariable | str = None,
        flip_output: None | BddVariable | str = None,
        limit: None | int = None
    ) -> Bdd:
        ...
    @staticmethod
    def apply3(
        a: Bdd,
        b: Bdd,
        c: Bdd,
        function: Callable[[None | bool, None | bool, None | bool], None | bool],
        flip_a: None | BddVariable | str = None,
        flip_b: None | BddVariable | str = None,
        flip_c: None | BddVariable | str = None,
        flip_out: None | BddVariable | str = None
    ) -> Bdd:
        ...
    @staticmethod
    def check2(
        left: Bdd,
        right: Bdd,
        function: Callable[[None | bool, None | bool], None | bool],
        flip_left: None | BddVariable | str = None,
        flip_right: None | BddVariable | str = None,
        flip_output: None | BddVariable | str = None
    ) -> tuple[bool, int]:
        ...
    @staticmethod
    def apply_nested(
        left: Bdd,
        right: Bdd,
        variables: Sequence[BddVariableType],
        outer_function: Callable[[None | bool, None | bool], None | bool],
        inner_function: Callable[[None | bool, None | bool], None | bool],
    ) -> Bdd:
        ...
    @staticmethod
    def apply_with_exists(
            left: Bdd,
            right: Bdd,
            variables: Sequence[BddVariableType],
            function: Callable[[None | bool, None | bool], None | bool],
    ) -> Bdd:
        ...
    @staticmethod
    def apply_with_for_all(
            left: Bdd,
            right: Bdd,
            variables: Sequence[BddVariableType],
            function: Callable[[None | bool, None | bool], None | bool],
    ) -> Bdd:
        ...
    def r_pick(self, variables: BddVariableType | Sequence[BddVariableType]) -> Bdd:
        ...
    def r_pick_random(self, variables: BddVariableType | Sequence[BddVariableType], seed: int | None = None) -> Bdd:
        ...
    def r_exist(self, variables: BddVariableType | Sequence[BddVariableType]) -> Bdd:
        ...
    def r_for_all(self, variables: BddVariableType | Sequence[BddVariableType]) -> Bdd:
        ...
    def r_restrict(self, values: BoolClauseType) -> Bdd:
        ...
    def r_select(self, values: BoolClauseType) -> Bdd:
        ...
    def witness(self) -> BddValuation | None:
        ...
    def valuation_first(self) -> BddValuation | None:
        ...
    def valuation_last(self) -> BddValuation | None:
        ...
    def valuation_random(self, seed: int | None = None) -> BddValuation | None:
        ...
    def valuation_most_positive(self) -> BddValuation | None:
        ...
    def valuation_most_negative(self) -> BddValuation | None:
        ...
    def valuation_iterator(self) -> Iterator[BddValuation]:
        ...
    def clause_first(self) -> BddPartialValuation | None:
        ...
    def clause_last(self) -> BddPartialValuation | None:
        ...
    def clause_random(self, seed: int | None = None) -> BddPartialValuation | None:
        ...
    def clause_necessary(self) -> BddPartialValuation | None:
        ...
    def clause_iterator(self) -> Iterator[BddPartialValuation]:
        ...
    def substitute(self, variable: BddVariableType, function: Bdd) -> Bdd:
        ...
    def rename(self, replace_with: Sequence[tuple[BddVariableType, BddVariableType]]) -> Bdd:
        ...

class BddPartialValuation:
    @overload
    def __init__(self, valuation: BddValuation | BddPartialValuation): ...
    @overload
    def __init__(self, ctx: BddVariableSet, values: Mapping[BddVariable, BoolType] | Mapping[str, BoolType]): ...
    def __init__(self, ctx, values) -> None:
        """
        A `BddPartialValuation` can be created as:
         - A copy of data from a `BddValuation` or a `BddPartialValuation`.
         - From a `BddVariableSet` "context" and a `BddVariableType -> BoolType` mapping, assuming the
           mapping only contains variables that are valid in the provided context.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, dict[BddVariable, bool]]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __len__(self) -> int:
        ...
    def __getitem__(self, key: BddVariableType) -> bool | None:
        ...
    def __setitem__(self, key: BddVariableType, value: BoolType | None) -> None:
        ...
    def __delitem__(self, key: BddVariableType) -> None:
        ...
    def __contains__(self, key: BddVariableType) -> bool:
        ...
    def keys(self) -> list[BddVariable]:
        ...
    def values(self) -> list[bool]:
        ...
    def items(self) -> list[tuple[BddVariable, bool]]:
        ...
    def to_dict(self) -> dict[BddVariable, bool]:
        ...
    def extends(self, other: BddPartialValuation) -> bool:
        ...
    def support_set(self) -> set[BddVariable]:
        ...

class BddValuation:
    @overload
    def __init__(self, valuation: BddValuation | BddPartialValuation): ...
    @overload
    def __init__(self, ctx: BddVariableSet, values: Sequence[BoolType] | None = None): ...
    def __init__(self, ctx, values) -> None:
        """
        A `BddValuation` can be created as:
         - A copy of a different `BddValuation`.
         - A copy of a `BddPartialValuation`, assuming it specifies the values of all relevant variables.
         - From a list of `BoolType` values and a `BddVariableSet` context, as long as its length is exactly
           the variable count.
        """
    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, list[bool]]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __len__(self) -> int:
        ...
    def __getitem__(self, key: BddVariableType) -> bool:
        ...
    def __setitem__(self, key: BddVariableType, value: BoolType) -> None:
        ...
    def __contains__(self, key: BddVariableType) -> bool:
        ...
    def keys(self) -> list[BddVariable]:
        ...
    def values(self) -> list[bool]:
        ...
    def items(self) -> list[tuple[BddVariable, bool]]:
        ...
    def extends(self, valuation: BddPartialValuation) -> bool:
        ...

class BooleanExpression:
    def __init__(self, value: BooleanExpression | str) -> None:
        """
        Build a new `BooleanExpression`, either as a copy of an existing expression, or from a string representation.
        """
    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> str:
        ...
    def __root__(self) -> BooleanExpression:
        ...
    @overload
    def __call__(self) -> bool: ...
    @overload
    def __call__(self, valuation: Mapping[str, BoolType]) -> bool: ...
    @overload
    def __call__(self, **kwargs: BoolType) -> bool: ...
    def __call__(self) -> bool: ...
    @staticmethod
    def mk_const(value: BoolType) -> BooleanExpression:
        ...
    @staticmethod
    def mk_var(name: str) -> BooleanExpression:
        ...
    @staticmethod
    def mk_not(value: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_and(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_or(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_imp(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_iff(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_xor(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_conjunction(items: Sequence[BooleanExpression]) -> BooleanExpression: ...
    @staticmethod
    def mk_disjunction(items: Sequence[BooleanExpression]) -> BooleanExpression: ...
    def is_const(self) -> bool:
        ...
    def is_var(self) -> bool:
        ...
    def is_not(self) -> bool:
        ...
    def is_and(self) -> bool:
        ...
    def is_or(self) -> bool:
        ...
    def is_imp(self) -> bool:
        ...
    def is_iff(self) -> bool:
        ...
    def is_xor(self) -> bool:
        ...
    def is_literal(self) -> bool:
        ...
    def is_binary(self) -> bool:
        ...
    def as_const(self) -> bool | None:
        ...
    def as_var(self) -> str | None:
        ...
    def as_not(self) -> BooleanExpression | None:
        ...
    def as_and(self) -> tuple[BooleanExpression, BooleanExpression] | None:
        ...
    def as_or(self) ->  tuple[BooleanExpression, BooleanExpression] | None:
        ...
    def as_imp(self) -> tuple[BooleanExpression, BooleanExpression] | None:
        ...
    def as_iff(self) -> tuple[BooleanExpression, BooleanExpression] | None:
        ...
    def as_xor(self) -> tuple[BooleanExpression, BooleanExpression] | None:
        ...
    def as_literal(self) -> tuple[str, bool] | None:
        ...
    def as_binary(self) -> tuple[BinaryOperator, BooleanExpression, BooleanExpression] | None:
        ...
    def support_set(self) -> set[str]:
        ...

class VariableId:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `VariableId` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class ParameterId:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `ParameterId` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class RegulatoryGraph:
    def __init__(self,
                 variables: Sequence[str] | None = None,
                 regulations: Sequence[Regulation[str] | str] | None = None
    ) -> None:
        """
        A `RegulatoryGraph` can be constructed from two optional arguments:
         - A list of variable names. If this list is not given, it is inferred from the list of regulations (inferred
           variables are sorted alphabetically).
         - A list of regulations. These can be either `NamedRegulation` dictionaries, or string objects compatible
           with the `.aeon` format notation.

        If you don't provide any arguments, an "empty" `RegulatoryGraph` is constructed with no variables
        and no regulations.
        """
    def __str__(self) -> str:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str], list[str]]:
        ...
    def __copy__(self) -> RegulatoryGraph:
        ...
    def __deepcopy__(self, memo: dict) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_file(file_path: str) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_aeon(file_content: str) -> RegulatoryGraph:
        ...
    def to_aeon(self) -> str:
        ...
    def to_dot(self) -> str:
        ...
    def variable_count(self) -> int:
        ...
    def variable_names(self) -> list[str]:
        ...
    def variables(self) -> list[VariableId]:
        ...
    def find_variable(self, variable: VariableIdType) -> None | VariableId:
        ...
    def get_variable_name(self, variable: VariableIdType) -> str:
        ...
    def set_variable_name(self, variable: VariableIdType, name: str) -> None:
        ...
    def regulation_count(self) -> int:
        ...
    def regulations(self) -> list[Regulation[VariableId]]:
        ...
    def regulation_strings(self) -> list[str]:
        ...
    def find_regulation(self, source: VariableIdType, target: VariableIdType) -> Regulation[VariableId] | None:
        ...
    def add_regulation(self, regulation: Regulation[str] | Regulation[VariableId] | str) -> None:
        ...
    def remove_regulation(self, source: VariableIdType, target: VariableIdType) -> Regulation[VariableId]:
        ...
    def ensure_regulation(self, regulation: Regulation[str] | Regulation[VariableId] | str) -> Regulation[VariableId] | None:
        ...
    def extend(self, variables: Sequence[str]) -> RegulatoryGraph:
        ...
    def drop(self, variables: VariableIdType | Sequence[VariableIdType]) -> RegulatoryGraph:
        ...
    def inline_variable(self, variable: VariableIdType) -> RegulatoryGraph:
        ...
    def predecessors(self, variable: VariableIdType) -> set[VariableId]:
        ...
    def successors(self, variable: VariableIdType) -> set[VariableId]:
        ...
    def backward_reachable(self,
                           pivots: VariableIdType | Sequence[VariableIdType],
                           subgraph: Sequence[VariableIdType] | None = None
                           ) -> set[VariableId]:
        ...
    def forward_reachable(self,
                          pivots: VariableIdType | Sequence[VariableIdType],
                          subgraph: Sequence[VariableIdType] | None = None
                          ) -> set[VariableId]:
        ...
    def feedback_vertex_set(self,
                            parity: SignType | None = None,
                            subgraph: Sequence[VariableIdType] | None = None
                            ) -> set[VariableId]:
        ...
    def independent_cycles(self,
                           parity: SignType | None = None,
                           subgraph: Sequence[VariableIdType] | None = None
                           ) -> list[list[VariableId]]:
        ...
    def strongly_connected_components(self, subgraph: Sequence[VariableIdType] | None = None) -> list[set[VariableId]]:
        ...
    def weakly_connected_components(self, subgraph: Sequence[VariableIdType] | None = None) -> list[set[VariableId]]:
        ...
    def shortest_cycle(self,
                       pivot: VariableIdType,
                       parity: SignType | None = None,
                       subgraph: Sequence[VariableIdType] | None = None,
                       length: int | None = None
    ) -> list[VariableId] | None:
        ...

class BooleanNetwork(RegulatoryGraph):
    def __init__(
            self,
            variables: Sequence[str] | None = None,
            regulations: Sequence[Regulation[str] | str] = None,
            parameters: Sequence[tuple[str, int]] | None = None,
            functions: Sequence[str | None] | Mapping[str, str] = None,
    ) -> None:
        """
        A new `BooleanNetwork` is constructed in a similar fashion to `RegulatoryGraph`, but additionally
        allows a list (or dictionary) of string update functions and a dictionary of explicit parameters.

        If variables are not specified, they can be inferred from the list of regulations. However, either
        variables *or* regulations need to be specified in a non-empty network. That is, variables and regulations
        cannot be currently inferred from functions alone. Similarly, explicit parameters are not inferred from
        update functions automatically.
        """
        ...
    def __str__(self) -> str:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str], list[str], list[tuple[str, int]], list[str]]:
        ...
    def __copy__(self) -> BooleanNetwork:
        ...
    def __deepcopy__(self, memo: dict) -> BooleanNetwork:
        ...
    @staticmethod
    def from_file(file_path: str, repair_graph: bool = False) -> BooleanNetwork:
        ...
    @staticmethod
    def from_aeon(file_contents: str) -> BooleanNetwork:
        ...
    def to_aeon(self) -> str:
        ...
    def set_variable_name(self, variable: VariableIdType, name: str) -> None:
        ...
    def add_regulation(self, regulation: Regulation[str] | Regulation[VariableId] | str) -> None:
        ...
    def remove_regulation(self, source: VariableIdType, target: VariableIdType) -> Regulation[VariableId]:
        ...
    def ensure_regulation(self, regulation: Regulation[str] | Regulation[VariableId] | str) -> Regulation[VariableId] | None:
        ...
    def extend(self, variables: Sequence[str]) -> BooleanNetwork:
        ...
    def drop(self, variables: VariableIdType | Sequence[VariableIdType]) -> BooleanNetwork:
        ...
    def inline_variable(self, variable: VariableIdType, repair_graph: bool = False) -> BooleanNetwork:
        ...
    def to_graph(self) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_bnet(file_contents: str, repair_graph: bool = False) -> BooleanNetwork:
        ...
    def to_bnet(self, rename_if_necessary: bool = True) -> str:
        ...
    @staticmethod
    def from_sbml(file_contents: str) -> BooleanNetwork:
        ...
    def to_sbml(self) -> str:
        ...
    def explicit_parameter_count(self) -> int:
        ...
    def implicit_parameter_count(self) -> int:
        ...
    def explicit_parameters(self) -> dict[ParameterId, int]:
        ...
    def implicit_parameters(self) -> dict[VariableId, int]:
        ...
    def explicit_parameter_names(self) -> list[str]:
        ...
    def get_explicit_parameter_name(self, parameter: ParameterIdType) -> str:
        ...
    def get_explicit_parameter_arity(self, parameter: ParameterIdType) -> int:
        ...
    def find_explicit_parameter(self, parameter: ParameterIdType) -> ParameterId | None:
        ...
    def add_explicit_parameter(self, name: str, arity: int) -> ParameterId:
        ...
    def get_update_function(self, variable: VariableIdType) -> UpdateFunction | None:
        ...
    def set_update_function(self, variable: VariableIdType, function: UpdateFunction | str | None) -> UpdateFunction | None:
        ...
    def infer_valid_graph(self) -> BooleanNetwork:
        ...
    def inline_constants(
            self, infer_constants: bool = False, repair_graph: bool = False
    ) -> BooleanNetwork: ...
    def inline_inputs(
            self, infer_inputs: bool = False, repair_graph: bool = False
    ) -> BooleanNetwork: ...
    def prune_unused_parameters(self) -> BooleanNetwork: ...

class UpdateFunction:
    def __init__(self, ctx: BooleanNetwork, value: str | UpdateFunction | BooleanExpression):
        """
        Build a new `UpdateFunction` in the context of the specified `BooleanNetwork`.
        The `value` can be either a string (in which case it is parsed), an `UpdateFunction`,
        in which case it is "translated" into the given context (IDs are updated based on matching names),
        or a `BooleanExpression`, in which case it also translated using variable names.
        """

    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BooleanNetwork, str]:
        ...
    def __root__(self) -> UpdateFunction:
        ...
    def __ctx__(self) -> BooleanNetwork:
        ...
    def __contains__(self, item: VariableId | ParameterId | str):
        ...
    @staticmethod
    def mk_const(ctx: BooleanNetwork, value: BoolType) -> UpdateFunction:
        ...
    @staticmethod
    def mk_var(ctx: BooleanNetwork, variable: VariableIdType) -> UpdateFunction:
        ...
    @staticmethod
    def mk_param(ctx: BooleanNetwork,
                 parameter: ParameterIdType,
                 arguments: Sequence[UpdateFunction | VariableId | str]
                 ) -> UpdateFunction: ...
    @staticmethod
    def mk_not(value: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_and(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_or(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_imp(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_iff(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_xor(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_binary(op: BinaryOperator, left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_conjunction(ctx: BooleanNetwork, args: Sequence[UpdateFunction | str]) -> UpdateFunction:
        ...
    @staticmethod
    def mk_disjunction(ctx: BooleanNetwork, args: Sequence[UpdateFunction | str]) -> UpdateFunction:
        ...
    def is_const(self) -> bool:
        ...
    def is_var(self) -> bool:
        ...
    def is_param(self) -> bool:
        ...
    def is_not(self) -> bool:
        ...
    def is_and(self) -> bool:
        ...
    def is_or(self) -> bool:
        ...
    def is_imp(self) -> bool:
        ...
    def is_iff(self) -> bool:
        ...
    def is_xor(self) -> bool:
        ...
    def is_literal(self) -> bool:
        ...
    def is_binary(self) -> bool:
        ...
    def as_const(self) -> None | bool:
        ...
    def as_var(self) -> None | VariableId:
        ...
    def as_param(self) -> None | tuple[ParameterId, list[UpdateFunction]]:
        ...
    def as_not(self) -> None | UpdateFunction:
        ...
    def as_and(self) -> None | tuple[UpdateFunction, UpdateFunction]:
        ...
    def as_or(self) -> None | tuple[UpdateFunction, UpdateFunction]:
        ...
    def as_imp(self) -> None | tuple[UpdateFunction, UpdateFunction]:
        ...
    def as_iff(self) -> None | tuple[UpdateFunction, UpdateFunction]:
        ...
    def as_xor(self) -> None | tuple[UpdateFunction, UpdateFunction]:
        ...
    def as_literal(self) -> None | tuple[VariableId, bool]:
        ...
    def as_binary(self) -> None | tuple[BinaryOperator, UpdateFunction, UpdateFunction]:
        ...
    def support_variables(self) -> set[VariableId]:
        ...
    def support_parameters(self) -> set[ParameterId]:
        ...
    def substitute_variable(self, variable: VariableIdType, function: UpdateFunction | str) -> UpdateFunction:
        ...
    def rename_all(self,
                   new_ctx: None | BooleanNetwork,
                   variables: Mapping[str, VariableIdType] | Mapping[VariableId, VariableIdType],
                   parameters: Mapping[str, ParameterIdType] | Mapping[ParameterId, ParameterIdType]
                   ) -> UpdateFunction: ...
    def simplify_constants(self) -> UpdateFunction:
        ...
    def distribute_negation(self) -> UpdateFunction:
        ...
    def to_and_or_normal_form(self) -> UpdateFunction:
        ...

class ModelAnnotation:
    def __init__(self, value: None | str = None):
        """
        Create a new `ModelAnnotation` with an optional string `value`.

        The child annotations can be then set similar to a normal dictionary, but this is not supported in the
        constructor for now.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __copy__(self) -> ModelAnnotation: ...
    def __deepcopy__(self, _memo: dict) -> ModelAnnotation: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> ModelAnnotation: ...
    def __setitem__(self,key: str, value: ModelAnnotation): ...
    def __delitem__(self, key: str) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    @property
    def value(self) -> str | None:
        """
        The optional string value of the model annotation.
        """
    @value.setter
    def value(self, value: str | None) -> None: ...
    @staticmethod
    def from_aeon(file_contents: str) -> ModelAnnotation: ...
    @staticmethod
    def from_file(path: str) -> ModelAnnotation: ...
    def values(self) -> list[ModelAnnotation]: ...
    def keys(self) -> list[str]: ...
    def items(self) -> list[tuple[str, ModelAnnotation]]: ...

class SymbolicContext:

    def __init__(self,
                 network: BooleanNetwork,
                 extra_variables: Mapping[str, int] | Mapping[VariableId, int] | None = None
                 ) -> None:
        """
        A `SymbolicContext` is created by providing a `BooleanNetwork` and optional
        `extra_variables` dictionary.

        At the moment, it is required that all explicit parameters (uninterpreted functions) that
        are declared in the given network are actually used by some update function in said
        network.

        *In the future, this restriction will be lifted, but it is not quite clear how soon will
        this happen.*

        Furthermore, due to this dependence on a `BooleanNetwork` structure, a
        `SymbolicContext` cannot be currently pickled. It is recommended that you instead save
        the `.aeon` representation of the `BooleanNetwork` in question.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    #def __repr__(self) -> str: ...
    #def __getnewargs__(self) -> str: ...
    def __copy__(self) -> SymbolicContext: ...
    def __deepcopy__(self, _memo: dict) -> SymbolicContext: ...
    def network_variable_count(self) -> int: ...
    def network_variable_names(self) -> list[str]: ...
    def network_variables(self) -> list[VariableId]: ...
    def network_bdd_variables(self) -> list[BddVariable]: ...
    def find_network_variable(self, variable: VariableIdType | BddVariable) -> None | VariableId: ...
    def find_network_bdd_variable(self, variable: VariableIdType | BddVariable) -> None | BddVariable: ...
    def get_network_variable_name(self, variable: VariableIdType | BddVariable) -> str: ...
    def extra_bdd_variable_count(self) -> int: ...
    def extra_bdd_variables_list(self) -> list[BddVariable]: ...
    def extra_bdd_variables(self) -> dict[VariableId, list[BddVariable]]: ...
    def explicit_function_count(self) -> int: ...
    def explicit_functions(self) -> list[VariableId]: ...
    def explicit_functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def explicit_functions_bdd_variables(self) -> dict[ParameterId, list[BddVariable]]: ...
    def implicit_function_count(self) -> int: ...
    def implicit_functions(self) -> list[VariableId]: ...
    def implicit_functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def implicit_functions_bdd_variables(self) -> dict[VariableId, list[BddVariable]]: ...
    def function_count(self) -> int: ...
    def functions(self) -> list[VariableId | ParameterId]: ...
    def functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def functions_bdd_variables(self) -> dict[VariableId | ParameterId, list[BddVariable]]: ...
    def find_function(self, function: VariableId | ParameterId | BddVariable | str) -> None | VariableId | ParameterId: ...
    def get_function_name(self, function: VariableId | ParameterId | BddVariable | str) -> str: ...
    def get_function_arity(self, function: VariableId | ParameterId | BddVariable | str) -> int: ...
    def get_function_table(self, function: VariableId | ParameterId | BddVariable | str) -> list[tuple[list[bool], BddVariable]]: ...
    def mk_constant(self, value: BoolType) -> Bdd: ...
    def mk_network_variable(self, variable: VariableIdType) -> Bdd: ...
    def mk_extra_bdd_variable(self, variable: VariableIdType | None = None, index: int | None = None) -> Bdd: ...
    def mk_function(self, function: VariableId | ParameterId | str, arguments: Sequence[UpdateFunction | Bdd | VariableId | str]) -> Bdd: ...
    def mk_update_function(self, function: UpdateFunction) -> Bdd: ...
    def bdd_variable_set(self) -> BddVariableSet: ...
    def transfer_from(self, bdd: Bdd, old_ctx: SymbolicContext) -> Bdd: ...
    def to_canonical_context(self) -> SymbolicContext: ...
    def eliminate_network_variable(self, variable: VariableIdType | BddVariable) -> SymbolicContext: ...

class ColorSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `ColorSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid set of colors.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __copy__(self) -> ColorSet: ...
    def __deepcopy__(self, _memo: dict) -> ColorSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[ColorModel]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: ColorSet) -> ColorSet: ...
    def minus(self, other: ColorSet) -> ColorSet: ...
    def union(self, other: ColorSet) -> ColorSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: ColorSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def pick_singleton(self) -> ColorSet: ...
    def symbolic_size(self) -> int: ...
    def to_bdd(self) -> Bdd: ...
    def items(self, retained: Sequence[VariableId | ParameterId | str] | None = None) -> Iterator[ColorModel]: ...

class ColorModel:
    def __ctx__(self) -> SymbolicContext: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: str | VariableId | ParameterId | BddVariable) -> bool: ...
    def __contains__(self, item: str | VariableId | ParameterId | BddVariable) -> bool: ...
    def keys(self) -> list[VariableId | ParameterId]: ...
    def values(self) -> list[BooleanExpression]: ...
    def items(self) -> list[tuple[VariableId | ParameterId, BooleanExpression]]: ...
    def to_dict(self) -> dict[VariableId | ParameterId, BooleanExpression]: ...
    def to_valuation(self) -> BddPartialValuation: ...
    @overload
    def instantiate(self, item: UpdateFunction) -> UpdateFunction: ...
    @overload
    def instantiate(self, item: BooleanNetwork) -> BooleanNetwork: ...
    @overload
    def instantiate(self, item: ParameterId | VariableId | str, args: Sequence[UpdateFunction | Bdd | VariableId | str]) -> UpdateFunction: ...
    def instantiate(self, item, args): ...

class VertexSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `VertexSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid set of vertices.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __copy__(self) -> VertexSet: ...
    def __deepcopy__(self, _memo: dict) -> VertexSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[VertexModel]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: VertexSet) -> VertexSet: ...
    def minus(self, other: VertexSet) -> VertexSet: ...
    def union(self, other: VertexSet) -> VertexSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: VertexSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def pick_singleton(self) -> VertexSet: ...
    def symbolic_size(self) -> int: ...
    def to_bdd(self) -> Bdd: ...
    def items(self, retained: Sequence[str | VariableId] | None = None) -> Iterator[VertexModel]: ...

class VertexModel:
    def __ctx__(self) -> SymbolicContext: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: str | VariableId | BddVariable) -> bool: ...
    def __contains__(self, item: str | VariableId | BddVariable) -> bool: ...
    def keys(self) -> list[VariableId]: ...
    def values(self) -> list[bool]: ...
    def items(self) -> list[tuple[VariableId, bool]]: ...
    def to_dict(self) -> dict[VariableId, bool]: ...
    def to_valuation(self) -> BddPartialValuation: ...

class ColoredVertexSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `ColoredVertexSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid colored set of vertices.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __copy__(self) -> ColoredVertexSet: ...
    def __deepcopy__(self, _memo: dict) -> ColoredVertexSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[ColorModel, VertexModel]]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def minus(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def union(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: ColoredVertexSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def symbolic_size(self) -> int: ...
    def colors(self) -> ColorSet: ...
    def vertices(self) -> VertexSet: ...
    def intersect_colors(self, colors: ColorSet) -> ColoredVertexSet: ...
    def intersect_vertices(self, vertices: VertexSet) -> ColoredVertexSet: ...
    def minus_colors(self, colors: ColorSet) -> ColoredVertexSet: ...
    def minus_vertices(self, vertices: VertexSet) -> ColoredVertexSet: ...
    def pick_color(self) -> ColoredVertexSet: ...
    def pick_vertex(self) -> ColoredVertexSet: ...
    def pick_singleton(self) -> ColoredVertexSet: ...
    def to_bdd(self) -> Bdd: ...
    def items(self,
              retained_variables: Sequence[VariableId | str] | None = None,
              retained_functions: Sequence[VariableId | ParameterId | str] | None = None
              ) -> Iterator[tuple[ColorModel, VertexModel]]: ...

class AsynchronousGraph:

    def __init__(self,
                 network: BooleanNetwork,
                 context: SymbolicContext | None = None,
                 unit_bdd: Bdd | None = None
                 ) -> None:
        """
        A new `AsynchronousGraph` is constructed from a `BooleanNetwork`. Optionally, you can also provide
        a `SymbolicContext` (that is compatible with said network), or a `unit_bdd` which restricts the set
        of vertices and colors of the `AsynchronousGraph`.
    
        Note that the graph structure is immutable: if you change the original network, you have to create
        a new `AsynchronousGraph`.
        """
    def __str__(self) -> str: ...
    def __copy__(self) -> AsynchronousGraph: ...
    def __deepcopy__(self, _memo: dict) -> AsynchronousGraph: ...
    def to_symbolic_context(self) -> SymbolicContext: ...
    def network_variable_count(self) -> int: ...
    def network_variable_names(self) -> list[str]: ...
    def network_variables(self) -> list[VariableId]: ...
    def find_network_variable(self, variable: VariableIdType) -> VariableId | None: ...
    def get_network_variable_name(self, variable: VariableIdType) -> str: ...
    def mk_empty_colored_vertices(self) -> ColoredVertexSet: ...
    def mk_empty_colors(self) -> ColorSet: ...
    def mk_empty_vertices(self) -> VertexSet: ...
    def mk_unit_colored_vertices(self) -> ColoredVertexSet: ...
    def mk_unit_colors(self) -> ColorSet: ...
    def mk_unit_vertices(self) -> VertexSet: ...
    def transfer_colors_from(self, colors: ColorSet, original_ctx: AsynchronousGraph) -> ColorSet: ...
    def transfer_vertices_from(self, vertices: VertexSet, original_ctx: AsynchronousGraph) -> VertexSet: ...
    @overload
    def transfer_from(self, set: ColorSet, original_ctx: AsynchronousGraph) -> ColorSet: ...
    @overload
    def transfer_from(self, set: VertexSet, original_ctx: AsynchronousGraph) -> VertexSet: ...
    @overload
    def transfer_from(self, set: ColoredVertexSet, original_ctx: AsynchronousGraph) -> ColoredVertexSet: ...
    def transfer_from(self, set, original_ctx): ...
    def mk_subspace(self, subspace: Mapping[VariableId, BoolType] | Mapping[str, BoolType]) -> ColoredVertexSet: ...
    def mk_subspace_vertices(self, subspace: Mapping[VariableId, BoolType] | Mapping[str, BoolType]) -> VertexSet: ...
    def mk_update_function(self, variable: VariableIdType) -> Bdd: ...
    def post(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def post_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def post_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def pre(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def pre_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def pre_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre_within(self, var:VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def can_post(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_post_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_post_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def can_pre(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_pre_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_pre_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...

BddVariableType: TypeAlias = BddVariable | str
VariableIdType: TypeAlias = VariableId | str
ParameterIdType: TypeAlias = ParameterId | str
BoolType: TypeAlias = bool | int
SignType: TypeAlias = Literal["positive", "+", "negative", "-"] | bool
BinaryOperator: TypeAlias = Literal["and", "or", "imp", "iff", "xor"]
BoolClauseType: TypeAlias = BddPartialValuation | BddValuation | Mapping[str, BoolType] | Mapping[BddVariable, BoolType]
BoolExpressionType: TypeAlias = BooleanExpression | str
IDT = TypeVar('IDT', covariant=True)
class Regulation(TypedDict, Generic[IDT]):
    source: IDT
    target: IDT
    sign: SignType | None
    essential: BoolType
