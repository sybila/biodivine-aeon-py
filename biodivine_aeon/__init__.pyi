from typing import TypeAlias, Literal

class BddVariable:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `BddVariable` using an `int` index of the variable.
        """
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class BddPointer:

    def __init__(self, value: bool | int | None = None) -> None:
        """
        Construct a new `BddPointer` using either a `bool` value, or an exact `int` index.

        If no value is given, defaults to `BddPointer.zero`.
        """
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...
    @staticmethod
    def zero() -> BddPointer:
        ...
    @staticmethod
    def one() -> BddPointer:
        ...
    def is_zero(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_terminal(self) -> bool:
        ...
    def as_bool(self) -> bool | None:
        ...

class BddVariableSetBuilder:
    def __init__(self, variables: list[str] | None = None) -> None:
        """
        Create a new `BddVariableSetBuilder`, optionally initialized with the given list of variables.
        """
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getstate__(self) -> list[str]:
        ...
    def __setstate__(self, state: list[str]):
        ...
    def add(self, name: str) -> BddVariable:
        ...
    def add_all(self, names: list[str]) -> list[BddVariable]:
        ...
    def build(self) -> BddVariableSet:
        ...


class BddVariableSet:
    def __init__(self, variables: int | list[str]):
        """
        A `BddVariableSet` is typically created using a list of variable names. However, you can also create
        an "anonymous" `BddVariableSet` using a variable count `n`. In such a case, the variables are automatically
        named $(x_0, \ldots, x_{n-1})$.
        """
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str]]:
        ...
    def variable_count(self) -> int:
        ...
    def variable_ids(self) -> list[BddVariable]:
        ...
    def variable_names(self) -> list[str]:
        ...
    def find_variable(self, variable: BddVariableType) -> BddVariable | None:
        ...
    def get_variable_name(self, variable: BddVariableType) -> str:
        ...
    def mk_false(self) -> Bdd:
        ...
    def mk_true(self) -> Bdd:
        ...
    def mk_const(self, value: BoolType) -> Bdd:
        ...
    def mk_literal(self, variable: BddVariableType, value: BoolType) -> Bdd:
        ...
    def mk_conjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_disjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_cnf(self, clauses: list[BoolClauseType]) -> Bdd:
        ...
    def mk_dnf(self, clauses: list[BoolClauseType]) -> Bdd:
        ...
    def mk_sat_exactly_k(self, k: int, variables: list[BddVariableType] | None) -> Bdd:
        ...
    def mk_sat_up_to_k(self, k: int, variables: list[BddVariableType] | None) -> Bdd:
        ...
    def eval_expression(self, expression: BoolExpressionType) -> Bdd:
        ...
    def transfer_from(self, value: Bdd, original_ctx: BddVariableSet) -> Bdd | None:
        ...


class Bdd:
    ...

class BddPartialValuation:
    ...

class BddValuation():
    def __init__(self,
         ctx: BddValuation | BddPartialValuation | BddVariableSet,
         values: None | list[BoolType] = None,
    ):
        """
        A `BddValuation` can be created as:
         - A copy of a different `BddValuation`.
         - A copy of a `BddPartialValuation`, assuming it specifies the
           values of all relevant variables.
         - From a list of `BoolType` values, as long as its length is exactly
           the variable count.
        """
    def __hash__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, list[bool]]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __len__(self) -> int:
        ...
    def __getitem__(self, key: BddVariableType) -> bool:
        ...
    def __setitem__(self, key: BddVariableType, value: BoolType) -> None:
        ...
    def __contains__(self, key: BddVariableType) -> bool:
        ...
    def keys(self) -> list[BddVariable]:
        ...
    def values(self) -> list[bool]:
        ...
    def items(self) -> list[tuple[BddVariable, bool]]:
        ...
    def extends(self, valuation: BddPartialValuation) -> bool:
        ...

class BooleanExpression:
    ...

BddVariableType: TypeAlias = BddVariable | str
BoolType: TypeAlias = Literal[0, 1] | bool
BoolClauseType: TypeAlias = BddPartialValuation | BddValuation | dict[BddVariableType, BoolType]
BoolExpressionType: TypeAlias = BooleanExpression | str