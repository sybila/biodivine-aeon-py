from typing import Literal, Callable, Sequence, TypedDict, Iterator, overload, Mapping, Union, Optional

LOG_NOTHING: Literal[0]
LOG_ESSENTIAL: Literal[1]
LOG_VERBOSE: Literal[2]
LOG_LEVEL: Literal[0, 1, 2]

class BddVariable:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `BddVariable` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class BddPointer:

    def __init__(self, value: Optional[Union[bool, int]] = None) -> None:
        """
        Construct a new `BddPointer` using either a `bool` value, or an exact `int` index.

        If no value is given, defaults to `BddPointer.zero`.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...
    @staticmethod
    def zero() -> BddPointer:
        ...
    @staticmethod
    def one() -> BddPointer:
        ...
    def is_zero(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_terminal(self) -> bool:
        ...
    def as_bool(self) -> Optional[bool]:
        ...

class BddVariableSetBuilder:
    def __init__(self, variables: Optional[Sequence[str]] = None) -> None:
        """
        Create a new `BddVariableSetBuilder`, optionally initialized with the given list of variables.
        """
    def __eq__(self, other) -> bool:
            ...
    def __ne__(self, other) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getstate__(self) -> list[str]:
        ...
    def __setstate__(self, state: list[str]):
        ...
    def add(self, name: str) -> BddVariable:
        ...
    def add_all(self, names: Sequence[str]) -> list[BddVariable]:
        ...
    def build(self) -> BddVariableSet:
        ...


class BddVariableSet:
    @overload
    def __init__(self, variables: int) -> None: ...
    @overload
    def __init__(self, variables: Sequence[str]) -> None: ...
    def __init__(self, variables) -> None:
        """
        A `BddVariableSet` is typically created using a list of variable names. However, you can also create
        an "anonymous" `BddVariableSet` using a variable count `n`. In such a case, the variables are automatically
        named $(x_0, \\ldots, x_{n-1})$.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str]]:
        ...
    def variable_count(self) -> int:
        ...
    def variable_ids(self) -> list[BddVariable]:
        ...
    def variable_names(self) -> list[str]:
        ...
    def find_variable(self, variable: BddVariableType) -> Optional[BddVariable]:
        ...
    def get_variable_name(self, variable: BddVariableType) -> str:
        ...
    def mk_false(self) -> Bdd:
        ...
    def mk_true(self) -> Bdd:
        ...
    def mk_const(self, value: BoolType) -> Bdd:
        ...
    def mk_literal(self, variable: BddVariableType, value: BoolType) -> Bdd:
        ...
    def mk_conjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_disjunctive_clause(self, clause: BoolClauseType) -> Bdd:
        ...
    def mk_cnf(self, clauses: Sequence[BoolClauseType]) -> Bdd:
        ...
    def mk_dnf(self, clauses: Sequence[BoolClauseType]) -> Bdd:
        ...
    def mk_sat_exactly_k(self, k: int, variables: Optional[Sequence[BddVariableType]] = None) -> Bdd:
        ...
    def mk_sat_up_to_k(self, k: int, variables: Optional[Sequence[BddVariableType]] = None) -> Bdd:
        ...
    def eval_expression(self, expression: BoolExpressionType) -> Bdd:
        ...
    def transfer_from(self, value: Bdd, original_ctx: BddVariableSet) -> Bdd:
        ...


class Bdd:
    @overload
    def __init__(self, valuation: Union[BddValuation, BddPartialValuation]) -> None: ...
    @overload
    def __init__(self, ctx: BddVariableSet, data: Union[bytes, str]) -> None: ...
    def __init__(self, ctx, data) -> None:
        """
        A `Bdd` can be created as:

         - A conjunction of literals defined by a `BddValuation` or a `BddPartialValuation`.
         - Deserialization of an object created with `Bdd.data_string()` or `Bdd.data_bytes()`.

        When deserializing, a `BddVariableSet` has to be provided to interpret individual BDD variables.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, bytes]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __call__(self, valuation: Union[BddValuation, list[BoolType]]) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def data_string(self) -> str:
        ...
    def data_bytes(self) -> bytes:
        ...
    def to_dot(self, zero_pruned: bool = True) -> str:
        ...
    def to_expression(self) -> BooleanExpression:
        ...
    def to_dnf(self) -> list[BddPartialValuation]:
        ...
    def to_cnf(self) -> list[BddPartialValuation]:
        ...
    def node_count(self) -> int:
        ...
    def node_count_per_variable(self) -> dict[BddVariable, int]:
        ...
    def structural_eq(self, other: Bdd) -> bool:
        ...
    def semantic_eq(self, other: Bdd) -> bool:
        ...
    def implies(self, other: Bdd) -> bool:
        ...
    def root(self) -> BddPointer:
        ...
    def node_links(self, pointer: BddPointer) -> tuple[BddPointer, BddPointer]:
        ...
    def node_variable(self, pointer: BddPointer) -> Optional[BddVariable]:
        ...
    def variable_count(self) -> int:
        ...
    def support_set(self) -> set[BddVariable]:
        ...
    def is_false(self) -> bool:
        ...
    def is_true(self) -> bool:
        ...
    def is_clause(self) -> bool:
        ...
    def is_valuation(self) -> bool:
        ...
    def cardinality(self, exact: bool = True) -> int:
        ...
    def l_not(self) -> Bdd:
        ...
    def l_and(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    def l_or(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    def l_imp(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    def l_iff(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    def l_xor(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    def l_and_not(self, other: Bdd, limit: Optional[int] = None) -> Bdd:
        ...
    @staticmethod
    def if_then_else(
            condition: Bdd,
            then: Bdd,
            other: Bdd,
    ) -> Bdd:
        ...
    @staticmethod
    def apply2(
        left: Bdd,
        right: Bdd,
        function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
        flip_left: Optional[BddVariableType] = None,
        flip_right: Optional[BddVariableType] = None,
        flip_output: Optional[BddVariableType] = None,
        limit: Optional[int] = None
    ) -> Bdd:
        ...
    @staticmethod
    def apply3(
        a: Bdd,
        b: Bdd,
        c: Bdd,
        function: Callable[[Optional[bool], Optional[bool], Optional[bool]], Optional[bool]],
        flip_a: Optional[BddVariableType] = None,
        flip_b: Optional[BddVariableType] = None,
        flip_c: Optional[BddVariableType] = None,
        flip_out: Optional[BddVariableType] = None
    ) -> Bdd:
        ...
    @staticmethod
    def check2(
        left: Bdd,
        right: Bdd,
        function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
        flip_left: Optional[BddVariableType] = None,
        flip_right: Optional[BddVariableType] = None,
        flip_output: Optional[BddVariableType] = None
    ) -> tuple[bool, int]:
        ...
    @staticmethod
    def apply_nested(
        left: Bdd,
        right: Bdd,
        variables: Sequence[BddVariableType],
        outer_function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
        inner_function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
    ) -> Bdd:
        ...
    @staticmethod
    def apply_with_exists(
            left: Bdd,
            right: Bdd,
            variables: Sequence[BddVariableType],
            function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
    ) -> Bdd:
        ...
    @staticmethod
    def apply_with_for_all(
            left: Bdd,
            right: Bdd,
            variables: Sequence[BddVariableType],
            function: Callable[[Optional[bool], Optional[bool]], Optional[bool]],
    ) -> Bdd:
        ...
    def r_pick(self, variables: Union[BddVariableType, Sequence[BddVariableType]]) -> Bdd:
        ...
    def r_pick_random(self, variables: Union[BddVariableType, Sequence[BddVariableType]], seed: Optional[int] = None) -> Bdd:
        ...
    def r_exist(self, variables: Union[BddVariableType, Sequence[BddVariableType]]) -> Bdd:
        ...
    def r_for_all(self, variables: Union[BddVariableType, Sequence[BddVariableType]]) -> Bdd:
        ...
    def r_restrict(self, values: BoolClauseType) -> Bdd:
        ...
    def r_select(self, values: BoolClauseType) -> Bdd:
        ...
    def witness(self) -> Optional[BddValuation]:
        ...
    def valuation_first(self) -> Optional[BddValuation]:
        ...
    def valuation_last(self) -> Optional[BddValuation]:
        ...
    def valuation_random(self, seed: Optional[int] = None) -> Optional[BddValuation]:
        ...
    def valuation_most_positive(self) -> Optional[BddValuation]:
        ...
    def valuation_most_negative(self) -> Optional[BddValuation]:
        ...
    def valuation_iterator(self) -> Iterator[BddValuation]:
        ...
    def clause_first(self) -> Optional[BddPartialValuation]:
        ...
    def clause_last(self) -> Optional[BddPartialValuation]:
        ...
    def clause_random(self, seed: Optional[int] = None) -> Optional[BddPartialValuation]:
        ...
    def clause_necessary(self) -> Optional[BddPartialValuation]:
        ...
    def clause_iterator(self) -> Iterator[BddPartialValuation]:
        ...
    def substitute(self, variable: BddVariableType, function: Bdd) -> Bdd:
        ...
    def rename(self, replace_with: Sequence[tuple[BddVariableType, BddVariableType]]) -> Bdd:
        ...

class BddPartialValuation:
    @overload
    def __init__(self, valuation: Union[BddValuation, BddPartialValuation]): ...
    @overload
    def __init__(self, ctx: BddVariableSet, values: Union[Mapping[BddVariable, BoolType], Mapping[str, BoolType]]): ...
    def __init__(self, ctx, values) -> None:
        """
        A `BddPartialValuation` can be created as:
         - A copy of data from a `BddValuation` or a `BddPartialValuation`.
         - From a `BddVariableSet` "context" and a `BddVariableType -> BoolType` mapping, assuming the
           mapping only contains variables that are valid in the provided context.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, dict[BddVariable, bool]]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __len__(self) -> int:
        ...
    def __getitem__(self, key: BddVariableType) -> Optional[bool]:
        ...
    def __setitem__(self, key: BddVariableType, value: Optional[BoolType]) -> None:
        ...
    def __delitem__(self, key: BddVariableType) -> None:
        ...
    def __contains__(self, key: BddVariableType) -> bool:
        ...
    def keys(self) -> list[BddVariable]:
        ...
    def values(self) -> list[bool]:
        ...
    def items(self) -> list[tuple[BddVariable, bool]]:
        ...
    def to_dict(self) -> dict[BddVariable, bool]:
        ...
    def extends(self, other: BddPartialValuation) -> bool:
        ...
    def support_set(self) -> set[BddVariable]:
        ...

class BddValuation:
    @overload
    def __init__(self, valuation: Union[BddValuation, BddPartialValuation]): ...
    @overload
    def __init__(self, ctx: BddVariableSet, values: Optional[Sequence[BoolType]] = None): ...
    def __init__(self, ctx, values) -> None:
        """
        A `BddValuation` can be created as:
         - A copy of a different `BddValuation`.
         - A copy of a `BddPartialValuation`, assuming it specifies the values of all relevant variables.
         - From a list of `BoolType` values and a `BddVariableSet` context, as long as its length is exactly
           the variable count.
        """
    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BddVariableSet, list[bool]]:
        ...
    def __ctx__(self) -> BddVariableSet:
        ...
    def __len__(self) -> int:
        ...
    def __getitem__(self, key: BddVariableType) -> bool:
        ...
    def __setitem__(self, key: BddVariableType, value: BoolType) -> None:
        ...
    def __contains__(self, key: BddVariableType) -> bool:
        ...
    def keys(self) -> list[BddVariable]:
        ...
    def values(self) -> list[bool]:
        ...
    def items(self) -> list[tuple[BddVariable, bool]]:
        ...
    def extends(self, valuation: BddPartialValuation) -> bool:
        ...

class BooleanExpression:
    def __init__(self, value: Union[BooleanExpression, str]) -> None:
        """
        Build a new `BooleanExpression`, either as a copy of an existing expression, or from a string representation.
        """
    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> str:
        ...
    def __root__(self) -> BooleanExpression:
        ...
    @overload
    def __call__(self) -> bool: ...
    @overload
    def __call__(self, valuation: Mapping[str, BoolType]) -> bool: ...
    @overload
    def __call__(self, **kwargs: BoolType) -> bool: ...
    def __call__(self) -> bool: ...
    @staticmethod
    def mk_const(value: BoolType) -> BooleanExpression:
        ...
    @staticmethod
    def mk_var(name: str) -> BooleanExpression:
        ...
    @staticmethod
    def mk_not(value: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_and(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_or(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_imp(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_iff(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_xor(left: BooleanExpression, right: BooleanExpression) -> BooleanExpression:
        ...
    @staticmethod
    def mk_conjunction(items: Sequence[BooleanExpression]) -> BooleanExpression: ...
    @staticmethod
    def mk_disjunction(items: Sequence[BooleanExpression]) -> BooleanExpression: ...
    def is_const(self) -> bool:
        ...
    def is_var(self) -> bool:
        ...
    def is_not(self) -> bool:
        ...
    def is_and(self) -> bool:
        ...
    def is_or(self) -> bool:
        ...
    def is_imp(self) -> bool:
        ...
    def is_iff(self) -> bool:
        ...
    def is_xor(self) -> bool:
        ...
    def is_literal(self) -> bool:
        ...
    def is_binary(self) -> bool:
        ...
    def as_const(self) -> Optional[bool]:
        ...
    def as_var(self) -> Optional[str]:
        ...
    def as_not(self) -> Optional[BooleanExpression]:
        ...
    def as_and(self) -> Optional[tuple[BooleanExpression, BooleanExpression]]:
        ...
    def as_or(self) ->  Optional[tuple[BooleanExpression, BooleanExpression]]:
        ...
    def as_imp(self) -> Optional[tuple[BooleanExpression, BooleanExpression]]:
        ...
    def as_iff(self) -> Optional[tuple[BooleanExpression, BooleanExpression]]:
        ...
    def as_xor(self) -> Optional[tuple[BooleanExpression, BooleanExpression]]:
        ...
    def as_literal(self) -> Optional[tuple[str, bool]]:
        ...
    def as_binary(self) -> Optional[tuple[BinaryOperator, BooleanExpression, BooleanExpression]]:
        ...
    def support_set(self) -> set[str]:
        ...

class VariableId:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `VariableId` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class ParameterId:
    def __init__(self, value: int = 0) -> None:
        """
        Construct a new `ParameterId` using an `int` index of the variable.
        """
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __lt__(self, other) -> bool:
        ...
    def __le__(self, other) -> bool:
        ...
    def __gt__(self, other) -> bool:
        ...
    def __ge__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __getnewargs__(self) -> tuple[int]:
        ...

class RegulatoryGraph:
    def __init__(self,
                 variables: Optional[Sequence[str]] = None,
                 regulations: Optional[Sequence[Union[NamedRegulation, str]]] = None
    ) -> None:
        """
        A `RegulatoryGraph` can be constructed from two optional arguments:
         - A list of variable names. If this list is not given, it is inferred from the list of regulations (inferred
           variables are sorted alphabetically).
         - A list of regulations. These can be either `NamedRegulation` dictionaries, or string objects compatible
           with the `.aeon` format notation.

        If you don't provide any arguments, an "empty" `RegulatoryGraph` is constructed with no variables
        and no regulations.
        """
    def __str__(self) -> str:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str], list[str]]:
        ...
    def __copy__(self) -> RegulatoryGraph:
        ...
    def __deepcopy__(self, memo: dict) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_file(file_path: str) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_aeon(file_content: str) -> RegulatoryGraph:
        ...
    def to_aeon(self) -> str:
        ...
    def to_dot(self) -> str:
        ...
    def variable_count(self) -> int:
        ...
    def variable_names(self) -> list[str]:
        ...
    def variables(self) -> list[VariableId]:
        ...
    def find_variable(self, variable: VariableIdType) -> Optional[VariableId]:
        ...
    def get_variable_name(self, variable: VariableIdType) -> str:
        ...
    def set_variable_name(self, variable: VariableIdType, name: str) -> None:
        ...
    def regulation_count(self) -> int:
        ...
    def regulations(self) -> list[IdRegulation]:
        ...
    def regulation_strings(self) -> list[str]:
        ...
    def find_regulation(self, source: VariableIdType, target: VariableIdType) -> Optional[IdRegulation]:
        ...
    def add_regulation(self, regulation: Union[Regulation, str]) -> None:
        ...
    def remove_regulation(self, source: VariableIdType, target: VariableIdType) -> IdRegulation:
        ...
    def ensure_regulation(self, regulation: Union[Regulation, str]) -> Optional[IdRegulation]:
        ...
    def extend(self, variables: Sequence[str]) -> RegulatoryGraph:
        ...
    def drop(self, variables: Union[VariableIdType, Sequence[VariableIdType]]) -> RegulatoryGraph:
        ...
    def inline_variable(self, variable: VariableIdType) -> RegulatoryGraph:
        ...
    def predecessors(self, variable: VariableIdType) -> set[VariableId]:
        ...
    def successors(self, variable: VariableIdType) -> set[VariableId]:
        ...
    def backward_reachable(self,
                           pivots: Union[VariableIdType, Sequence[VariableIdType]],
                           subgraph: Optional[Sequence[VariableIdType]] = None
                           ) -> set[VariableId]:
        ...
    def forward_reachable(self,
                          pivots: Union[VariableIdType, Sequence[VariableIdType]],
                          subgraph: Optional[Sequence[VariableIdType]] = None
                          ) -> set[VariableId]:
        ...
    def feedback_vertex_set(self,
                            parity: Optional[SignType] = None,
                            subgraph: Optional[Sequence[VariableIdType]] = None
                            ) -> set[VariableId]:
        ...
    def independent_cycles(self,
                           parity: Optional[SignType] = None,
                           subgraph: Optional[Sequence[VariableIdType]] = None
                           ) -> list[list[VariableId]]:
        ...
    def strongly_connected_components(self, subgraph: Optional[Sequence[VariableIdType]] = None) -> list[set[VariableId]]:
        ...
    def weakly_connected_components(self, subgraph: Optional[Sequence[VariableIdType]] = None) -> list[set[VariableId]]:
        ...
    def shortest_cycle(self,
                       pivot: VariableIdType,
                       parity: Optional[SignType] = None,
                       subgraph: Optional[Sequence[VariableIdType]] = None,
                       length: Optional[int] = None,
    ) -> Optional[list[VariableId]]:
        ...

class BooleanNetwork(RegulatoryGraph):
    def __init__(
            self,
            variables: Optional[Sequence[str]] = None,
            regulations: Optional[Sequence[Union[NamedRegulation, str]]] = None,
            parameters: Optional[Sequence[tuple[str, int]]] = None,
            functions: Optional[Union[Sequence[Optional[str]], Mapping[str, str]]] = None,
    ) -> None:
        """
        A new `BooleanNetwork` is constructed in a similar fashion to `RegulatoryGraph`, but additionally
        allows a list (or dictionary) of string update functions and a dictionary of explicit parameters.

        If variables are not specified, they can be inferred from the list of regulations. However, either
        variables *or* regulations need to be specified in a non-empty network. That is, variables and regulations
        cannot be currently inferred from functions alone. Similarly, explicit parameters are not inferred from
        update functions automatically.
        """
        ...
    def __str__(self) -> str:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[list[str], list[str], list[tuple[str, int]], list[str]]:
        ...
    def __copy__(self) -> BooleanNetwork:
        ...
    def __deepcopy__(self, memo: dict) -> BooleanNetwork:
        ...
    @staticmethod
    def from_file(file_path: str, repair_graph: bool = False) -> BooleanNetwork:
        ...
    @staticmethod
    def from_aeon(file_contents: str) -> BooleanNetwork:
        ...
    def to_aeon(self) -> str:
        ...
    def set_variable_name(self, variable: VariableIdType, name: str) -> None:
        ...
    def add_regulation(self, regulation: Union[Regulation, str]) -> None:
        ...
    def remove_regulation(self, source: VariableIdType, target: VariableIdType) -> IdRegulation:
        ...
    def ensure_regulation(self, regulation: Union[Regulation, str]) -> Optional[IdRegulation]:
        ...
    def extend(self, variables: Sequence[str]) -> BooleanNetwork:
        ...
    def drop(self, variables: Union[VariableIdType, Sequence[VariableIdType]]) -> BooleanNetwork:
        ...
    def inline_variable(self, variable: VariableIdType, repair_graph: bool = False) -> BooleanNetwork:
        ...
    def to_graph(self) -> RegulatoryGraph:
        ...
    @staticmethod
    def from_bnet(file_contents: str, repair_graph: bool = False) -> BooleanNetwork:
        ...
    def to_bnet(self, rename_if_necessary: bool = True) -> str:
        ...
    @staticmethod
    def from_sbml(file_contents: str) -> BooleanNetwork:
        ...
    def to_sbml(self) -> str:
        ...
    def explicit_parameter_count(self) -> int:
        ...
    def implicit_parameter_count(self) -> int:
        ...
    def explicit_parameters(self) -> dict[ParameterId, int]:
        ...
    def implicit_parameters(self) -> dict[VariableId, int]:
        ...
    def explicit_parameter_names(self) -> list[str]:
        ...
    def get_explicit_parameter_name(self, parameter: ParameterIdType) -> str:
        ...
    def get_explicit_parameter_arity(self, parameter: ParameterIdType) -> int:
        ...
    def find_explicit_parameter(self, parameter: ParameterIdType) -> Optional[ParameterId]:
        ...
    def add_explicit_parameter(self, name: str, arity: int) -> ParameterId:
        ...
    def get_update_function(self, variable: VariableIdType) -> Optional[UpdateFunction]:
        ...
    def set_update_function(self, variable: VariableIdType, function: Optional[Union[str, UpdateFunction]]) -> Optional[UpdateFunction]:
        ...
    def infer_valid_graph(self) -> BooleanNetwork:
        ...
    def inline_constants(
            self, infer_constants: bool = False, repair_graph: bool = False
    ) -> BooleanNetwork: ...
    def inline_inputs(
            self, infer_inputs: bool = False, repair_graph: bool = False
    ) -> BooleanNetwork: ...
    def prune_unused_parameters(self) -> BooleanNetwork: ...

class UpdateFunction:
    def __init__(self, ctx: BooleanNetwork, value: Union[str, UpdateFunction, BooleanExpression]):
        """
        Build a new `UpdateFunction` in the context of the specified `BooleanNetwork`.
        The `value` can be either a string (in which case it is parsed), an `UpdateFunction`,
        in which case it is "translated" into the given context (IDs are updated based on matching names),
        or a `BooleanExpression`, in which case it also translated using variable names.
        """

    def __hash__(self) -> int:
        ...
    def __eq__(self, other) -> bool:
        ...
    def __ne__(self, other) -> bool:
        ...
    def __str__(self) -> str:
        ...
    def __repr__(self) -> str:
        ...
    def __getnewargs__(self) -> tuple[BooleanNetwork, str]:
        ...
    def __root__(self) -> UpdateFunction:
        ...
    def __ctx__(self) -> BooleanNetwork:
        ...
    def __contains__(self, item: Union[VariableId, ParameterId, str]):
        ...
    @staticmethod
    def mk_const(ctx: BooleanNetwork, value: BoolType) -> UpdateFunction:
        ...
    @staticmethod
    def mk_var(ctx: BooleanNetwork, variable: VariableIdType) -> UpdateFunction:
        ...
    @staticmethod
    def mk_param(ctx: BooleanNetwork,
                 parameter: ParameterIdType,
                 arguments: Sequence[Union[UpdateFunction, VariableId, str]]
                 ) -> UpdateFunction: ...
    @staticmethod
    def mk_not(value: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_and(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_or(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_imp(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_iff(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_xor(left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_binary(op: BinaryOperator, left: UpdateFunction, right: UpdateFunction) -> UpdateFunction:
        ...
    @staticmethod
    def mk_conjunction(ctx: BooleanNetwork, args: Sequence[Union[UpdateFunction, str]]) -> UpdateFunction:
        ...
    @staticmethod
    def mk_disjunction(ctx: BooleanNetwork, args: Sequence[Union[UpdateFunction, str]]) -> UpdateFunction:
        ...
    def is_const(self) -> bool:
        ...
    def is_var(self) -> bool:
        ...
    def is_param(self) -> bool:
        ...
    def is_not(self) -> bool:
        ...
    def is_and(self) -> bool:
        ...
    def is_or(self) -> bool:
        ...
    def is_imp(self) -> bool:
        ...
    def is_iff(self) -> bool:
        ...
    def is_xor(self) -> bool:
        ...
    def is_literal(self) -> bool:
        ...
    def is_binary(self) -> bool:
        ...
    def as_const(self) -> Optional[bool]:
        ...
    def as_var(self) -> Optional[VariableId]:
        ...
    def as_param(self) -> Optional[tuple[ParameterId, list[UpdateFunction]]]:
        ...
    def as_not(self) -> Optional[UpdateFunction]:
        ...
    def as_and(self) -> Optional[tuple[UpdateFunction, UpdateFunction]]:
        ...
    def as_or(self) -> Optional[tuple[UpdateFunction, UpdateFunction]]:
        ...
    def as_imp(self) -> Optional[tuple[UpdateFunction, UpdateFunction]]:
        ...
    def as_iff(self) -> Optional[tuple[UpdateFunction, UpdateFunction]]:
        ...
    def as_xor(self) -> Optional[tuple[UpdateFunction, UpdateFunction]]:
        ...
    def as_literal(self) -> Optional[tuple[VariableId, bool]]:
        ...
    def as_binary(self) -> Optional[tuple[BinaryOperator, UpdateFunction, UpdateFunction]]:
        ...
    def support_variables(self) -> set[VariableId]:
        ...
    def support_parameters(self) -> set[ParameterId]:
        ...
    def substitute_all(self, substitution: Union[Mapping[str, Union[UpdateFunction, str]], Mapping[VariableId, Union[UpdateFunction, str]]]) -> UpdateFunction:
        ...
    def rename_all(self,
                   new_ctx: Optional[BooleanNetwork] = None,
                   variables: Optional[Union[Mapping[str, VariableIdType], Mapping[VariableId, VariableIdType]]] = None,
                   parameters: Optional[Union[Mapping[str, ParameterIdType], Mapping[ParameterId, ParameterIdType]]] = None,
                   ) -> UpdateFunction: ...
    def simplify_constants(self) -> UpdateFunction:
        ...
    def distribute_negation(self) -> UpdateFunction:
        ...
    def to_and_or_normal_form(self) -> UpdateFunction:
        ...
    def as_expression(self) -> BooleanExpression:
        ...

class ModelAnnotation:
    def __init__(self, value: Optional[str] = None):
        """
        Create a new `ModelAnnotation` with an optional string `value`.

        The child annotations can be then set similar to a normal dictionary, but this is not supported in the
        constructor for now.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __copy__(self) -> ModelAnnotation: ...
    def __deepcopy__(self, _memo: dict) -> ModelAnnotation: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> ModelAnnotation: ...
    def __setitem__(self,key: str, value: ModelAnnotation): ...
    def __delitem__(self, key: str) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    @property
    def value(self) -> Optional[str]:
        """
        The optional string value of the model annotation.
        """
    @value.setter
    def value(self, value: Optional[str]) -> None: ...
    @staticmethod
    def from_aeon(file_contents: str) -> ModelAnnotation: ...
    @staticmethod
    def from_file(path: str) -> ModelAnnotation: ...
    def values(self) -> list[ModelAnnotation]: ...
    def keys(self) -> list[str]: ...
    def items(self) -> list[tuple[str, ModelAnnotation]]: ...

class SymbolicContext:

    def __init__(self,
                 network: BooleanNetwork,
                 extra_variables: Optional[Union[Mapping[str, int], Mapping[VariableId, int]]] = None
                 ) -> None:
        """
        A `SymbolicContext` is created by providing a `BooleanNetwork` and optional
        `extra_variables` dictionary.

        At the moment, it is required that all explicit parameters (uninterpreted functions) that
        are declared in the given network are actually used by some update function in said
        network.

        *In the future, this restriction will be lifted, but it is not quite clear how soon will
        this happen.*

        Furthermore, due to this dependence on a `BooleanNetwork` structure, a
        `SymbolicContext` cannot be currently pickled. It is recommended that you instead save
        the `.aeon` representation of the `BooleanNetwork` in question.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    #def __repr__(self) -> str: ...
    #def __getnewargs__(self) -> str: ...
    def __copy__(self) -> SymbolicContext: ...
    def __deepcopy__(self, _memo: dict) -> SymbolicContext: ...
    def network_variable_count(self) -> int: ...
    def network_variable_names(self) -> list[str]: ...
    def network_variables(self) -> list[VariableId]: ...
    def network_bdd_variables(self) -> list[BddVariable]: ...
    def find_network_variable(self, variable: Union[VariableIdType, BddVariable]) -> Optional[VariableId]: ...
    def find_network_bdd_variable(self, variable: Union[VariableIdType, BddVariable]) -> Optional[BddVariable]: ...
    def get_network_variable_name(self, variable: Union[VariableIdType, BddVariable]) -> str: ...
    def extra_bdd_variable_count(self) -> int: ...
    def extra_bdd_variables_list(self) -> list[BddVariable]: ...
    def extra_bdd_variables(self) -> dict[VariableId, list[BddVariable]]: ...
    def explicit_function_count(self) -> int: ...
    def explicit_functions(self) -> list[VariableId]: ...
    def explicit_functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def explicit_functions_bdd_variables(self) -> dict[ParameterId, list[BddVariable]]: ...
    def implicit_function_count(self) -> int: ...
    def implicit_functions(self) -> list[VariableId]: ...
    def implicit_functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def implicit_functions_bdd_variables(self) -> dict[VariableId, list[BddVariable]]: ...
    def function_count(self) -> int: ...
    def functions(self) -> list[Union[VariableId, ParameterId]]: ...
    def functions_bdd_variables_list(self) -> list[BddVariable]: ...
    def functions_bdd_variables(self) -> dict[Union[VariableId, ParameterId], list[BddVariable]]: ...
    def find_function(self, function: Union[VariableId, ParameterId, BddVariable, str]) -> Optional[Union[VariableId, ParameterId]]: ...
    def get_function_name(self, function: Union[VariableId, ParameterId, BddVariable, str]) -> str: ...
    def get_function_arity(self, function: Union[VariableId, ParameterId, BddVariable, str]) -> int: ...
    def get_function_table(self, function: Union[VariableId, ParameterId, BddVariable, str]) -> list[tuple[list[bool], BddVariable]]: ...
    def mk_constant(self, value: BoolType) -> Bdd: ...
    def mk_network_variable(self, variable: VariableIdType) -> Bdd: ...
    def mk_extra_bdd_variable(self, variable: Optional[VariableIdType] = None, index: Optional[int] = None) -> Bdd: ...
    def mk_function(self, function: Union[VariableId, ParameterId, str], arguments: Sequence[Union[UpdateFunction, Bdd, VariableId, str]]) -> Bdd: ...
    def mk_update_function(self, function: UpdateFunction) -> Bdd: ...
    def bdd_variable_set(self) -> BddVariableSet: ...
    def transfer_from(self, bdd: Bdd, old_ctx: SymbolicContext) -> Bdd: ...
    def to_canonical_context(self) -> SymbolicContext: ...
    def eliminate_network_variable(self, variable: Union[VariableIdType, BddVariable]) -> SymbolicContext: ...

class SymbolicSpaceContext(SymbolicContext):
    def __init__(self,
                 network: BooleanNetwork,
                 extra_variables: Optional[Union[Mapping[str, int], Mapping[VariableId, int]]] = None
                 ) -> None:
        """
        A `SymbolicSpaceContext` is created from a `BooleanNetwork`, just as a regular
        `SymbolicContext`. However, no extra symbolic variables can be specified in this case.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    #def __repr__(self) -> str: ...
    #def __getnewargs__(self) -> str: ...
    def __copy__(self) -> SymbolicContext: ...
    #def __deepcopy__(self, _memo: dict) -> SymbolicContext: ...
    def get_positive_space_variable(self, variable: VariableIdType) -> BddVariable: ...
    def get_negative_space_variable(self, variable: VariableIdType) -> BddVariable: ...
    def mk_can_go_to_true(self, functions: Bdd) -> Bdd: ...
    def mk_empty_colored_spaces(self) -> ColoredSpaceSet: ...
    def mk_empty_spaces(self) -> SpaceSet: ...
    def mk_unit_colored_spaces(self, graph: Optional[AsynchronousGraph] = None) -> ColoredSpaceSet: ...
    def mk_unit_spaces(self) -> SpaceSet: ...
    def mk_unit_bdd(self) -> Bdd: ...
    @overload
    def mk_sub_spaces(self, set: ColoredSpaceSet) -> ColoredSpaceSet: ...
    @overload
    def mk_sub_spaces(self, set: SpaceSet) -> SpaceSet: ...
    @overload
    def mk_sub_spaces(self, set: Bdd) -> Bdd: ...
    def mk_sub_spaces(self, set): ...
    @overload
    def mk_super_spaces(self, set: ColoredSpaceSet) -> ColoredSpaceSet: ...
    @overload
    def mk_super_spaces(self, set: SpaceSet) -> SpaceSet: ...
    @overload
    def mk_super_spaces(self, set: Bdd) -> Bdd: ...
    def mk_super_spaces(self, set): ...
    def mk_singleton(self, space: Union[Mapping[str, BoolType], Mapping[VariableId, BoolType]]) -> SpaceSet: ...

class ColorSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `ColorSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid set of colors.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __copy__(self) -> ColorSet: ...
    def __deepcopy__(self, _memo: dict) -> ColorSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[ColorModel]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: ColorSet) -> ColorSet: ...
    def minus(self, other: ColorSet) -> ColorSet: ...
    def union(self, other: ColorSet) -> ColorSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: ColorSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def pick_singleton(self) -> ColorSet: ...
    def symbolic_size(self) -> int: ...
    def to_bdd(self) -> Bdd: ...
    def items(self, retained: Optional[Sequence[Union[VariableId, ParameterId, str]]] = None) -> Iterator[ColorModel]: ...

class ColorModel:
    def __ctx__(self) -> SymbolicContext: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: Union[str, VariableId, ParameterId, BddVariable]) -> bool: ...
    def __contains__(self, item: Union[str, VariableId, ParameterId, BddVariable]) -> bool: ...
    def keys(self) -> list[Union[VariableId, ParameterId]]: ...
    def values(self) -> list[BooleanExpression]: ...
    def items(self) -> list[tuple[Union[VariableId, ParameterId], BooleanExpression]]: ...
    def to_dict(self) -> dict[Union[VariableId, ParameterId], BooleanExpression]: ...
    def to_valuation(self) -> BddPartialValuation: ...
    @overload
    def instantiate(self, item: UpdateFunction) -> UpdateFunction: ...
    @overload
    def instantiate(self, item: BooleanNetwork) -> BooleanNetwork: ...
    @overload
    def instantiate(self, item: Union[ParameterId, VariableId, str], args: Sequence[Union[UpdateFunction, Bdd, VariableId, str]]) -> UpdateFunction: ...
    def instantiate(self, item, args): ...

class VertexSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `VertexSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid set of vertices.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __copy__(self) -> VertexSet: ...
    def __deepcopy__(self, _memo: dict) -> VertexSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[VertexModel]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: VertexSet) -> VertexSet: ...
    def minus(self, other: VertexSet) -> VertexSet: ...
    def union(self, other: VertexSet) -> VertexSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: VertexSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def pick_singleton(self) -> VertexSet: ...
    def symbolic_size(self) -> int: ...
    def to_bdd(self) -> Bdd: ...
    def items(self, retained: Optional[Sequence[Union[str, VariableId]]] = None) -> Iterator[VertexModel]: ...

class VertexModel:
    def __ctx__(self) -> SymbolicContext: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: Union[str, VariableId, BddVariable]) -> bool: ...
    def __contains__(self, item: Union[str, VariableId, BddVariable]) -> bool: ...
    def keys(self) -> list[VariableId]: ...
    def values(self) -> list[bool]: ...
    def items(self) -> list[tuple[VariableId, bool]]: ...
    def to_dict(self) -> dict[VariableId, bool]: ...
    def to_valuation(self) -> BddPartialValuation: ...

class SpaceSet:
    def __init__(self, ctx: SymbolicSpaceContext, bdd: Bdd):
        """
        Normally, a new `SpaceSet` is derived using a `SymbolicSpaceContext`. However, in some
        cases you may want to create it manually from a `SymbolicSpaceContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid set of spaces.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __copy__(self) -> SpaceSet: ...
    def __deepcopy__(self, _memo: dict) -> SpaceSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[SpaceModel]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: SpaceSet) -> SpaceSet: ...
    def minus(self, other: SpaceSet) -> SpaceSet: ...
    def union(self, other: SpaceSet) -> SpaceSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: SpaceSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def pick_singleton(self) -> SpaceSet: ...
    def symbolic_size(self) -> int: ...
    def to_bdd(self) -> Bdd: ...
    def items(self, retained: Optional[Sequence[Union[str, VariableId]]] = None) -> Iterator[SpaceModel]: ...

class SpaceModel:
    def __ctx__(self) -> SymbolicSpaceContext: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: Union[str, VariableId]) -> Optional[bool]: ...
    def __contains__(self, item: Union[str, VariableId]) -> Optional[bool]: ...
    def keys(self) -> list[VariableId]: ...
    def values(self) -> list[Optional[bool]]: ...
    def items(self) -> list[tuple[VariableId, Optional[bool]]]: ...
    def to_dict(self) -> dict[VariableId, Optional[bool]]: ...
    def to_valuation(self) -> BddPartialValuation: ...

class ColoredVertexSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `ColoredVertexSet` is derived using an `AsynchronousGraph`. However, in some
        cases you may want to create it manually from a `SymbolicContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid colored set of vertices.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __copy__(self) -> ColoredVertexSet: ...
    def __deepcopy__(self, _memo: dict) -> ColoredVertexSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[ColorModel, VertexModel]]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def minus(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def union(self, other: ColoredVertexSet) -> ColoredVertexSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: ColoredVertexSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def is_subspace(self) -> bool: ...
    def symbolic_size(self) -> int: ...
    def colors(self) -> ColorSet: ...
    def vertices(self) -> VertexSet: ...
    def intersect_colors(self, colors: ColorSet) -> ColoredVertexSet: ...
    def intersect_vertices(self, vertices: VertexSet) -> ColoredVertexSet: ...
    def minus_colors(self, colors: ColorSet) -> ColoredVertexSet: ...
    def minus_vertices(self, vertices: VertexSet) -> ColoredVertexSet: ...
    def pick_color(self) -> ColoredVertexSet: ...
    def pick_vertex(self) -> ColoredVertexSet: ...
    def pick_singleton(self) -> ColoredVertexSet: ...
    def to_bdd(self) -> Bdd: ...
    def items(self,
              retained_variables: Optional[Sequence[VariableIdType]] = None,
              retained_functions: Optional[Sequence[Union[VariableId, ParameterId, str]]] = None
              ) -> Iterator[tuple[ColorModel, VertexModel]]: ...

class ColoredSpaceSet:
    def __init__(self, ctx: SymbolicContext, bdd: Bdd):
        """
        Normally, a new `ColoredSpaceSet` is derived using an `SymbolicSpaceContext`. However, in some
        cases you may want to create it manually from a `SymbolicSpaceContext` and a `Bdd`.

        Just keep in mind that this method does not check that the provided `Bdd` is semantically
        a valid colored set of vertices.
        """
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __copy__(self) -> ColoredSpaceSet: ...
    def __deepcopy__(self, _memo: dict) -> ColoredSpaceSet: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[ColorModel, SpaceModel]]: ...
    def cardinality(self) -> int: ...
    def intersect(self, other: ColoredSpaceSet) -> ColoredSpaceSet: ...
    def minus(self, other: ColoredSpaceSet) -> ColoredSpaceSet: ...
    def union(self, other: ColoredSpaceSet) -> ColoredSpaceSet: ...
    def is_empty(self) -> bool: ...
    def is_subset(self, other: ColoredSpaceSet) -> bool: ...
    def is_singleton(self) -> bool: ...
    def symbolic_size(self) -> int: ...
    def colors(self) -> ColorSet: ...
    def spaces(self) -> SpaceSet: ...
    def intersect_colors(self, colors: ColorSet) -> ColoredSpaceSet: ...
    def intersect_spaces(self, vertices: SpaceSet) -> ColoredSpaceSet: ...
    def minus_colors(self, colors: ColorSet) -> ColoredSpaceSet: ...
    def minus_spaces(self, vertices: SpaceSet) -> ColoredSpaceSet: ...
    def pick_color(self) -> ColoredSpaceSet: ...
    def pick_space(self) -> ColoredSpaceSet: ...
    def pick_singleton(self) -> ColoredSpaceSet: ...
    def to_bdd(self) -> Bdd: ...
    def items(self,
              retained_variables: Optional[Sequence[VariableIdType]] = None,
              retained_functions: Optional[Sequence[Union[VariableId, ParameterId, str]]] = None
              ) -> Iterator[tuple[ColorModel, SpaceModel]]: ...

class AsynchronousGraph:

    def __init__(self,
                 network: BooleanNetwork,
                 context: Optional[SymbolicContext] = None,
                 unit_bdd: Optional[Bdd] = None
                 ) -> None:
        """
        A new `AsynchronousGraph` is constructed from a `BooleanNetwork`. Optionally, you can also provide
        a `SymbolicContext` (that is compatible with said network), or a `unit_bdd` which restricts the set
        of vertices and colors of the `AsynchronousGraph`.
    
        Note that the graph structure is immutable: if you change the original network, you have to create
        a new `AsynchronousGraph`.
        """
    def __str__(self) -> str: ...
    def __copy__(self) -> AsynchronousGraph: ...
    def __deepcopy__(self, _memo: dict) -> AsynchronousGraph: ...
    def symbolic_context(self) -> SymbolicContext: ...
    def network_variable_count(self) -> int: ...
    def network_variable_names(self) -> list[str]: ...
    def network_variables(self) -> list[VariableId]: ...
    def find_network_variable(self, variable: VariableIdType) -> Optional[VariableId]: ...
    def get_network_variable_name(self, variable: VariableIdType) -> str: ...
    def mk_empty_colored_vertices(self) -> ColoredVertexSet: ...
    def mk_empty_colors(self) -> ColorSet: ...
    def mk_empty_vertices(self) -> VertexSet: ...
    def mk_unit_colored_vertices(self) -> ColoredVertexSet: ...
    def mk_unit_colors(self) -> ColorSet: ...
    def mk_unit_vertices(self) -> VertexSet: ...
    def transfer_colors_from(self, colors: ColorSet, original_ctx: AsynchronousGraph) -> ColorSet: ...
    def transfer_vertices_from(self, vertices: VertexSet, original_ctx: AsynchronousGraph) -> VertexSet: ...
    @overload
    def transfer_from(self, set: ColorSet, original_ctx: AsynchronousGraph) -> ColorSet: ...
    @overload
    def transfer_from(self, set: VertexSet, original_ctx: AsynchronousGraph) -> VertexSet: ...
    @overload
    def transfer_from(self, set: ColoredVertexSet, original_ctx: AsynchronousGraph) -> ColoredVertexSet: ...
    def transfer_from(self, set, original_ctx): ...
    def mk_subspace(self, subspace: Union[Mapping[VariableId, BoolType], Mapping[str, BoolType]]) -> ColoredVertexSet: ...
    def mk_subspace_vertices(self, subspace: Union[Mapping[VariableId, BoolType], Mapping[str, BoolType]]) -> VertexSet: ...
    def mk_update_function(self, variable: VariableIdType) -> Bdd: ...
    def post(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def post_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def post_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def pre(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def pre_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def pre_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_post_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_pre_within(self, var:VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def can_post(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_post_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_post_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def can_pre(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_pre_out(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    #def can_pre_within(self, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_post_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre_out(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...
    def var_can_pre_within(self, var: VariableIdType, set: ColoredVertexSet) -> ColoredVertexSet: ...

class TrapSpaces:
    @staticmethod
    def minimize(ctx: SymbolicSpaceContext, set: ColoredSpaceSet) -> ColoredSpaceSet: ...
    @staticmethod
    def maximize(ctx: SymbolicSpaceContext, set: ColoredSpaceSet) -> ColoredSpaceSet: ...
    @staticmethod
    def essential_symbolic(network: BooleanNetwork, ctx: SymbolicSpaceContext, restriction: ColoredSpaceSet) -> ColoredSpaceSet: ...
    @staticmethod
    def minimal_symbolic(network: BooleanNetwork, ctx: SymbolicSpaceContext, restriction: ColoredSpaceSet) -> ColoredSpaceSet: ...

class FixedPoints:
    @staticmethod
    def symbolic(graph: AsynchronousGraph, set: ColoredVertexSet) -> ColoredVertexSet: ...
    @staticmethod
    def symbolic_vertices(graph: AsynchronousGraph, set: ColoredVertexSet) -> VertexSet: ...
    @staticmethod
    def symbolic_colors(graph: AsynchronousGraph, set: ColoredVertexSet) -> ColorSet: ...

class Attractors:
    @staticmethod
    def attractors(graph: AsynchronousGraph, set: ColoredVertexSet) -> list[ColoredVertexSet]: ...

class Percolation:
    @staticmethod
    def percolate_subspace(graph: AsynchronousGraph, subspace: Union[Mapping[VariableId, BoolType], Mapping[str, BoolType]]) -> dict[VariableId, bool]: ...

BddVariableType = Union[BddVariable, str]
VariableIdType = Union[VariableId, str]
ParameterIdType = Union[ParameterId, str]
BoolType = Union[bool, int]
SignType = Union[bool, Literal["positive", "+", "negative", "-"]]
BinaryOperator = Literal["and", "or", "imp", "iff", "xor"]
BoolClauseType = Union[BddPartialValuation, BddValuation, Mapping[str, BoolType], Mapping[BddVariable, BoolType]]
BoolExpressionType = Union[BooleanExpression, str]
# IDT = TypeVar('IDT', covariant=True)
# class Regulation(TypedDict, Generic[IDT]):
#     source: IDT
#     target: IDT
#     sign: Optional[SignType]
#     essential: BoolType
class IdRegulation(TypedDict):
    source: VariableId
    target: VariableId
    sign: Optional[SignType]
    essential: BoolType
class NamedRegulation(TypedDict):
    source: str
    target: str
    sign: Optional[SignType]
    essential: BoolType
Regulation = Union[IdRegulation, NamedRegulation]